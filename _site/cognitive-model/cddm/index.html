<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Circular Drift-diffusion Model | Cognitive Models</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="Circular Drift-diffusion Model" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Disclaimer: We have striven to minimize the number of errors. However, we cannot guarantee the note is 100% accurate. This tutorial requires the CDDM module, which is part of an ongoing research project, so has not released, yet." />
<meta property="og:description" content="Disclaimer: We have striven to minimize the number of errors. However, we cannot guarantee the note is 100% accurate. This tutorial requires the CDDM module, which is part of an ongoing research project, so has not released, yet." />
<link rel="canonical" href="http://localhost:4000/cognitive-model/cddm/" />
<meta property="og:url" content="http://localhost:4000/cognitive-model/cddm/" />
<meta property="og:site_name" content="Cognitive Models" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-03T06:11:35+00:00" />
<script type="application/ld+json">
{"datePublished":"2020-10-03T06:11:35+00:00","description":"Disclaimer: We have striven to minimize the number of errors. However, we cannot guarantee the note is 100% accurate. This tutorial requires the CDDM module, which is part of an ongoing research project, so has not released, yet.","@type":"Article","url":"http://localhost:4000/cognitive-model/cddm/","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/siteicon.png"}},"headline":"Circular Drift-diffusion Model","dateModified":"2020-10-03T06:11:35+00:00","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

		<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Cognitive Models" />

		<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700">
		<link rel="stylesheet" href="/css/main.css">
		<link rel="apple-touch-icon" href="/apple-touch-icon.png">
		<link rel="icon" type="image/png" href="/touch-icon.png" sizes="192x192">
		<link rel="icon" type="image/png" href="/images/favicon.png">

		
	</head>

	<body>
	  <header>
	    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script>
	    
			<h1>
				<a href="/"><img src="/images/emblem.svg" width="40" height="40" alt="Cognitive Models logo"></a>
				Cognitive Models
				<button type="button" class="open-nav" id="open-nav"></button>
			</h1>

			<form action="/search/" method="get">
				<input type="text" name="q" id="search-input" placeholder="Search" autofocus>
				<input type="submit" value="Search" style="display: none;">
			</form>

			<nav >
				<ul>
					<li class="nav-item top-level ">
						
						<a href="/"></a>
					</li>
				</ul>

				<ul>
					
					
						<li class="nav-item top-level ">
							
							<a href="/BUGS/hnormal/">BUGS Examples Volumn 1</a>
							<ul>
								
									<li class="nav-item "><a href="/BUGS/hnormal/">Hierarchical Normal Model</a></li>
								
									<li class="nav-item "><a href="/BUGS/seeds/">Random effect logistic regression</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/approximation/kde/">Likelihood Free Method</a>
							<ul>
								
									<li class="nav-item "><a href="/approximation/kde/">Kernel Density Estimation</a></li>
								
									<li class="nav-item "><a href="/approximation/pda/">Probability Density Approximation</a></li>
								
									<li class="nav-item "><a href="/approximation/ppda/">Parallel Probability Density Approximation</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/basics/model_array/">Modelling Basics</a>
							<ul>
								
									<li class="nav-item "><a href="/basics/model_array/">Model Array</a></li>
								
									<li class="nav-item "><a href="/basics/simulation/">Simulation</a></li>
								
									<li class="nav-item "><a href="/basics/descriptive/">Descriptive Statistics</a></li>
								
									<li class="nav-item "><a href="/basics/summary/">Summary Statistics</a></li>
								
									<li class="nav-item "><a href="/basics/leastsq/">Least Square Method</a></li>
								
									<li class="nav-item "><a href="/basics/mle/">Maximising Likelihoods</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/bayes-basics/theorem/">Bayesian Basics</a>
							<ul>
								
									<li class="nav-item "><a href="/bayes-basics/theorem/">Bayes' Theorem</a></li>
								
									<li class="nav-item "><a href="/bayes-basics/prior/">Prior Distribution</a></li>
								
									<li class="nav-item "><a href="/bayes-basics/likelihood/">Model Likelihood</a></li>
								
									<li class="nav-item "><a href="/bayes-basics/posterior/">Posterior Distribution</a></li>
								
									<li class="nav-item "><a href="/bayes-basics/diagnosis/">Checking Fitted Models</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level current">
							
							<a href="/cognitive-model/lba/">Cognitive Model</a>
							<ul>
								
									<li class="nav-item "><a href="/cognitive-model/lba/">LBA Model</a></li>
								
									<li class="nav-item "><a href="/cognitive-model/pm/">PM Model</a></li>
								
									<li class="nav-item "><a href="/cognitive-model/plba/">PLBA Model</a></li>
								
									<li class="nav-item "><a href="/cognitive-model/ddm/">Diffusion Decision Model</a></li>
								
									<li class="nav-item "><a href="/cognitive-model/ddm1c/">One-choice Diffusion Decision Model</a></li>
								
									<li class="nav-item current"><a href="/cognitive-model/cddm/">Circular Drift-diffusion Model</a></li>
								
									<li class="nav-item "><a href="/cognitive-model/pddm/">PDDM</a></li>
								
									<li class="nav-item "><a href="/cognitive-model/lba3/">Three-accumulator LBA Model</a></li>
								
									<li class="nav-item "><a href="/cognitive-model/lca/">LCA Model</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/fixed-effect-model/one_participant/">Fixed-effects Model</a>
							<ul>
								
									<li class="nav-item "><a href="/fixed-effect-model/one_participant/">One Participant</a></li>
								
									<li class="nav-item "><a href="/fixed-effect-model/many_participants/">Multiple Participants</a></li>
								
									<li class="nav-item "><a href="/fixed-effect-model/cddm12S/">CDDM</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/mcmc/mcmc/">Modern Bayesian Statistics</a>
							<ul>
								
									<li class="nav-item "><a href="/mcmc/mcmc/">Markov Chain Monte Carlo</a></li>
								
									<li class="nav-item "><a href="/mcmc/rwm/">Random Walk Metropolis</a></li>
								
									<li class="nav-item "><a href="/mcmc/hastings/">Metropolis-Hastings</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/random-effect-model/hlba/">Hierarchical Model</a>
							<ul>
								
									<li class="nav-item "><a href="/random-effect-model/hlba/">HLBA Model</a></li>
								
									<li class="nav-item "><a href="/random-effect-model/hddm/">HDDM</a></li>
								
									<li class="nav-item "><a href="/random-effect-model/shooting-decision1/">Shooting Decision Model - Recovery Study</a></li>
								
									<li class="nav-item "><a href="/random-effect-model/shooting-decision2/">Shooting Decision Model - Empirical Data</a></li>
								
									<li class="nav-item "><a href="/random-effect-model/hcddm/">HCDDM</a></li>
								
									<li class="nav-item "><a href="/random-effect-model/hpm/">HPM Model</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/sampling/genetic/">Sampling Techniques</a>
							<ul>
								
									<li class="nav-item "><a href="/sampling/genetic/">Population-based Monte Carlo</a></li>
								
									<li class="nav-item "><a href="/sampling/crossover/">Crossover</a></li>
								
									<li class="nav-item "><a href="/sampling/migration/">Migration</a></li>
								
									<li class="nav-item "><a href="/sampling/mutation/">Mutation</a></li>
								
									<li class="nav-item "><a href="/sampling/demc/">Differential Evolution Monte Carlo</a></li>
								
									<li class="nav-item "><a href="/sampling/demcmc/">Differential Evolution Markov Chain Monte Carlo</a></li>
								
									<li class="nav-item "><a href="/sampling/dgmc/">Distributed Genetic Monte Carlo</a></li>
								
							</ul>
						</li>
					
				</ul>

				<ul>
					<li class="nav-item top-level ">
						
						<a href="/changelog/">Change Log</a>
					</li>
				</ul>
			</nav>
		</header>

		<section class="main">
			<div class="page-header">
				<h2>Cognitive Model</h2>
				<h3>Circular Drift-diffusion Model</h3>
			</div>
			<article class="content">
				<blockquote>
  <p><strong>Disclaimer</strong>: We have striven to minimize the number of errors. However, we cannot guarantee the note is 100% accurate. This tutorial requires the CDDM module, which is part of an ongoing research project, so has not released, yet.</p>
</blockquote>

<p>Circular drift-diffusion model (CDDM) is a two-dimension process model. It could be viewed as an extension of the one-dimension diffusion model. One assumption of the 1-D diffusion model is it posits a single unit accumulator accrues evidence towards two opposing, an upper and a lower, boundaries. As illustrated in the right panel in the following figure, when the accumulator moves towards one boundary, it at the same time moves away from the other. This inevitable situation is in fact a powerful design that restricts the model to account for a set of processes. Therefore, the model provides a concise and successful account for the cognitive processes in the now ubiquitous two-alternative forced-choice (2AFC) task in cognitive psychology.</p>

<p><img src="/images/cognitive-model/random_walk.png" alt="random_walk" />
Figure 1. 1-D and 2-D random walk processes.</p>

<p>However, when one wants to model the tasks allowing more than two response types, it is not immediately clear how the 1-D diffusion model can extend to this situation. One usual option is to use the accumulator models (Ratcliff, Smith, Brown, &amp; McKoon, 2016), for example, the LBA model, the LCA model or the feed forward inhibition model (Brown &amp; Heathcote, 2008; Usher &amp; McClellend, 2001; Mazurek et al., 2003; Niwa &amp; Ditterich, 2008, Roe et al., 2001). These models use the absolute, as oppose to the relative, evidence criteria, as the stopping rule for the process. In this design, each response type corresponds to one unit accumulator, accuring evidence towards either one or multiple response thresholds.</p>

<p>Although it was discussed largely regarding to its utility to model the continuous report task (Smith, 2016), the circular drift-diffusion model can also account for the tasks with more than two responses. The aim of this tutorial is to demonstrate how this can be done using ggdmc. This tutorial is divided into three sections. First, we introduce three CDDM core functions, <strong>dcircle</strong>, <strong>rcircle</strong>, and <strong>rcircle_process</strong>. Following the convention of R language, <strong>d</strong> refers to probability density function and <strong>r</strong> refers to random number generation. Instead of recording only the response time and angle, <strong>rcircle_process</strong> simulates the 2-D diffusion process and records the trace, as shown in the left panel in the illustration figure. The source codes, CDDM.hpp and CDDM.cpp, provide the implementation details regarding the three functions.</p>

<p>In the second section, we replicated the simulation studies in Smith (2016) to check the accuracy of our CDDM module.</p>

<p>Next, we conducted a series of parameter recovery studies, using maximum likelihood estimation. The purpose of the recovery study is to provide a template when one wishes to fit an empirical data set from a continuous report task.</p>

<p>For using the Bayesian method to fit the CDDM, please go to the tutorials of fixed-effect and hierarchical models.</p>

<h1 id="core-functions">Core functions</h1>
<p>The 2-D diffusion model has four main parameters, <em>v1</em>, <em>v2</em>, <em>a</em>, and <em>t0</em>. <em>v1</em> and <em>v2</em> are the average increments of the evidence on the x and y axes. They are the two components of the drift vector <em><strong>v</strong></em>, whose magnitude is the Euclidean norm ||<em><strong>v</strong></em>||.</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
& || v || = \sqrt{v_1^2 + v_2^2} 
& \theta_v = tan^{-1}({v_2 / v1})

\end{align*} %]]></script>

<p>As the equation suggestes, a second way to describe the drift vector is via the left-hand side of the equation, using the magnitude and phase angle, <script type="math/tex">\theta_v</script> of the drift vector. The drift vector drives the evidence growth towards the decision boundary, <em>a</em>, which, in the case of 2-D diffusion model, is the circumference of a disc (Figure 1).</p>

<p>The stochastic component of the accumulation process is driven by the within-trial variability, <script type="math/tex">\sigma^2</script>, the diffusion coefficient. For simplicity, the SD, <script type="math/tex">\sigma</script>, corresponding to the two components of the drift vector are assumed as identical and independent of each other. We code it as sigma1 and sigma2 to remind the user that this is an assumption and the user can relax it by tweaking the source codes. For now, we recommend to set them as 1.</p>

<p>The time it takes the accumulator hit the boundary is the decision time. The response time is the decision time plus with the non-decision time, <em>t0</em>.</p>

<p>In summary, the parameter vector composes of:</p>

<ol>
  <li><strong>v1</strong>, the mean drift rate on the x axis,</li>
  <li><strong>v2</strong>, the mean drift rate on the y axis,</li>
  <li><strong>a</strong>, the response criterion,</li>
  <li><strong>t0</strong>, the non-decision time</li>
  <li><strong>sigma1</strong>, the within trial drift-rate standard deviation on the x axis,</li>
  <li><strong>sigma2</strong>, the within trial drift-rate standard deviation on the y axis.</li>
  <li><strong>eta1</strong> and <strong>eta2</strong> are two parameters related to the drift rate SD. They are usually set as 0.</li>
</ol>

<h2 id="random-walk-process">Random-walk Process</h2>
<p>Figure 1 was generated by the <strong>rcircle_process</strong>, the 2-D random-walk and <strong>r1d</strong>, the 1-D random-walk processes.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require(ggdmc)
## random walk 2d
## Set the upper bound of simulation time and each time step as 0.1 ms
tmax &lt;- 2   
h    &lt;- 1e-4    

p.vector &lt;- c(v1=0, v2=0, a=1, t0=0, sigma1=1, sigma2=1, eta1=0, eta2=0)
res0 &lt;- rcircle_process(P=p.vector, tmax=tmax, h=h)
str(res0)
## List of 3
##  $ out : num [1:3, 1] 0.732 -2.551 0
##  $ xPos: num [1:20001, 1] 0 0 0.0074 -0.0104 -0.0172 ...
##  $ yPos: num [1:20001, 1] 0 0 -0.0183 -0.0258 -0.0364 ...


## random walk 1d
p.vector &lt;- c(v=0, a=1, z=.5, t0=0, s=1)
res1 &lt;- r1d(P=p.vector, tmax=tmax, h=h)
idx &lt;- sum(!is.na(res0$Xt)); idx
str(res1)
## List of 3
##  $ T  : num [1:20001, 1] 0e+00 1e-04 2e-04 3e-04 4e-04 5e-04 6e-04 7e-04 8e-04 9e-04 ...
##  $ out: num [1:2, 1] 0.221 0
##  $ Xt : num [1:20001, 1] 0.5 0.51 0.513 0.507 0.51 ...

## Plot the traces of 1-D and 2-D diffusion processes
png(filename='random_walk_2d.png', 800, 600)
par(mfrow=c(1,2), pty="s")
plotCircle(res0$xPos[,1], res0$yPos[,1], a=1)
plot(res1$T[1:idx], res1$Xt[1:idx], type='l', ylim=c(0, 1), xlab='DT (s)',
     ylab='Evidence')
abline(h=1, lty='dotted', lwd=1.5)
abline(h=0, lty='dotted', lwd=1.5)
points(x=0, y=p.vector[3], col='red')
dev.off()

</code></pre></div></div>

<h2 id="random-number-generation">Random number generation</h2>
<p>To simulate multiple observations, <strong>rcircle</strong> allows the user to enter the number of observation via the <strong>n</strong> option. The implementation is simply a for loop running the code of the <strong>rcirle_process</strong> function repeatedly.  Another useful option in <strong>rcircle</strong> is <strong>nw</strong>, which allows the user to divide the response angles into <em>nw</em> response categories.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n &lt;- 150000
tmax &lt;- 2
h &lt;- 1e-4
p.vector &lt;- c(v1=1, v2=1, a=1, t0=0, sigma1=1, sigma2=1, eta1=0, eta2=0)

## Took ~160 s. Divide the angles evenly into 11 categories
res0 &lt;- rcircle(n=n, P=p.vector, tmax=tmax, h=h, nw=11)

d &lt;- data.frame(res0)
names(d) &lt;- c("R", "RT", "A")
## R stores the centered angles of the response category.
## A stores the actual hitting angles.
# dplyr::tbl_df(d)
# A tibble: 150,000 x 3
#         R    RT      A
#     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
#  1 -0.286 0.116 -0.310
#  2  0.857 0.262  0.968
#  3 -0.286 0.329 -0.151
#  4  0.857 0.467  0.774
#  ...
# … with 149,990 more rows

</code></pre></div></div>

<h2 id="joint-densities-of-zero-drift-process">Joint densities of zero-drift process</h2>
<p>In the following, we simulated 50,000 observations from the zero-drift process by setting v1 and v2 to 0.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n &lt;- 50000    ## 50,000 observations
h &lt;- 1e-4     ## Define 0.1 ms as one time step
tmax &lt;- 2     ## Define maximum decision time 
nw &lt;- 11      ## Divide the hitting angles into 11 categories
w &lt;- 2*pi/nw  ## The width of each category of the hitting angles

## Define zero-drift parameter vector
p.vector &lt;- c(v1=0, v2=0, a=1, t0=0, sigma1=1, sigma2=1, eta1=0, eta2=0)

## ~60 seconds
res0 &lt;- rcircle(n=n, P=p.vector, tmax=tmax, h=h, nw=11)

## The simulation result is stored as a numerical matrix, so we convert it to 
## an R data.frame
d &lt;- data.frame(R = factor(round(res0[,1], 2)), RT = res0[,2], A = res0[,3])
</code></pre></div></div>

<p>Because we divide the hitting angles into 11 bins and are handeling bivariate data, we create a customerised histogram function to count the numbers of observation in each bin. Note one bin in this case is indexed by both the response times and hitting angles, so the densities, <strong>Gt</strong>, is a nw <script type="math/tex">\times</script> ntime matrix.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## See the end of this tutorial for the implementation of the function  
res1 &lt;- histogram_cddm(d, P=p.vector, nw=nw, tmax=tmax, h=h)

# List of 9
# $ Theta    : num [1:11] -3.142 -2.57 -1.999 -1.428 -0.857 ...
# $ Mt       : num [1:11] 0.499 0.514 0.51 0.5 0.511 ...
# $ Pt       : num [1:11] 0.161 0.158 0.156 0.158 0.163 ...
# $ time_grid: num [1:20001] 0e+00 1e-04 2e-04 3e-04 4e-04 5e-04 6e-04 7e-04 8e-04 9e-04 ...
# $ Gt       : num [1:11, 1:20001] 1.08e-16 9.96e-17 1.06e-16 9.77e-17 1.32e-16 ...
# $ Pmt      : num [1:11] 1 1 1 1 1 1 1 1 1 1 ...
# $ Mtscale  : num [1:11, 1:20001] 1 1 1 1 1 1 1 1 1 1 ...
# $ Gt_count : num [1:11, 1:20001] 0 0 0 0 0 0 0 0 0 0 ...
# $ d        :'data.frame':	220011 obs. of  3 variables:
#   ..$ R : Factor w/ 11 levels "-3.14","-2.57",..: 1 1 1 1 1 1 1 1 1 1 ...
#   ..$ RT: num [1:220011] 0e+00 1e-04 2e-04 3e-04 4e-04 5e-04 6e-04 7e-04 8e-04 9e-04 ...
#   ..$ D : num [1:220011] 1.90e-16 1.09e-16 2.21e-16 3.46e-17 2.05e-16 ...

</code></pre></div></div>

<p><em>Gt</em> is the joint density matrix, with <em>nw</em> row and <em>ntime</em> column. The time grid
is constructed based on the maximum simulation time, <strong>tmax</strong> and the user-defined time step, <strong>h</strong>. <em>d</em> is a data.frame, which rearranges the densities stored in <strong>Gt</strong>, the hitting angles stored in <em>Theta</em>, and the response times stored in <em>time_grid</em>.</p>

<h2 id="probability-density-function">Probability Density Function</h2>
<p><strong>dcircle</strong> calculates the predicted probability densities of the 2-D diffusion process.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>den &lt;- dcircle(d$RT, d$A, P=p.vector, tmax=tmax, kmax=50, sz=2/h, nw=50)
## Because den is a column vector. We convet it to a row vector.
d$D &lt;- den[,1]

</code></pre></div></div>

<p>The following figure show the joing densities calculated from the simulations.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>thetai &lt;- levels(res1$d$R)

dat0 &lt;- vector("list", length=nw)
dat1 &lt;- vector("list", length=nw)
for(i in 1:nw) {
  tmp0 &lt;- res1$d[res1$d$R==thetai[i],] ## simulation
  dat0[[i]] &lt;- tmp0[order(tmp0$RT),]

  tmp1 &lt;- d[d$R==thetai[i],]           ## predicted
  dat1[[i]] &lt;- tmp1[order(tmp1$RT),]
}

colors &lt;- RColorBrewer:::brewer.pal(9, "Set1")

par(pty='s')
plot(dat0[[1]]$RT, dat0[[1]]$D, col="grey60", ylim=c(0, .4),
     type='l', xlab='Time(s)', ylab='Joint density', cex.lab=2,
     cex.axis = 1.5)
lines(dat1[[1]]$RT, dat1[[1]]$D, lwd=2)

for(i in 2:nw)
{
  lines(dat0[[i]]$RT, dat0[[i]]$D, lwd=1, col=colors[i])
  lines(dat1[[i]]$RT, dat1[[i]]$D, lwd=2)
}
dev.off()
</code></pre></div></div>

<p><img src="/images/cognitive-model/zero_drift_density0.png" alt="zero-drift0" />
Figure 2. The joint densities of response times and response angles of zero-drift prcess. The black line shows the predicted densities.</p>

<p>Because the simulated observations are from the zero-drift process, the hitting angles do not affect the densities. This can be seen in Figure 3, which presents the histogrames in individual subplot.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## require ggplot2

x0 &lt;- res1$d
x1 &lt;- d
x0$TYPE &lt;- 'Simulation'
x1$TYPE &lt;- 'Prediction'
tmp0 &lt;- x0[, c("RT", "D", "R", "TYPE")]
tmp1 &lt;- x1[, c("RT", "D", "R", "TYPE")]
x2 &lt;- rbind(tmp0, tmp1)

p0 &lt;- ggplot(x2, aes(x=RT, y=D, colour=R)) +
  geom_line(aes(size=TYPE)) +
  scale_size_manual(values = c(1, .25) ) +
  xlab("RT(s)") + ylab("Joint density") +
  coord_cartesian(ylim=c(0, .4)) +
  facet_wrap(~R) +
  theme_bw(base_size=14) +
  theme(aspect.ratio=1,
        legend.position = 'none')

print(p0)
</code></pre></div></div>

<p><img src="/images/cognitive-model/zero_drift_density1.png" alt="zero-drift1" />
Figure 3. The upper panel shows the hitting-angle categories.</p>

<p>Similarly, we compare the predicted and simulated densities of the non-zero drift 2-D diffusion process.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Test 1, nonzero-drift simulation --------
n &lt;- 150000
tmax &lt;- 2
h &lt;- 1e-4
nw &lt;- 11
p.vector &lt;- c(v1=1, v2=1, a=1, t0=0, sigma1=1, sigma2=1, eta1=0, eta2=0)

## 179.4 s
res0 &lt;- rcircle(n=n, P=p.vector, tmax=tmax, h=h, nw=nw)

d &lt;- data.frame(R=factor(round(res0[,1], 2)), RT=res0[,2], A=res0[,3])
res1 &lt;- histogram_cddm(d, P=p.vector, nw=nw, tmax=tmax, h=h)
x0 &lt;- res1$d
thetai &lt;- levels(res1$d$R)

## Predicted density -----------------------
res2 &lt;- dcircle300(p.vector, tmax=2, kmax=50, sz=300, nw=nw)

x1  &lt;- NULL
for(i in 1:nw) {
  x1 &lt;- rbind(x1, data.frame(RT = res2$DT, A = rep(res2$R[i], 300), D = res2$Gt[i,]))
}

res3 &lt;- divider(x1, nw=nw)
x1 &lt;- dplyr::tbl_df(res3$d) ## overwrite x1

dplyr::tbl_df(x0)
dplyr::tbl_df(x1)

dat0 &lt;- vector("list", length=nw)
dat1 &lt;- vector("list", length=nw)
for(i in 1:nw) {
  tmp0 &lt;- x0[x0$R==thetai[i],]
  dat0[[i]] &lt;- tmp0[order(tmp0$RT),]

  tmp1 &lt;- x1[x1$R==thetai[i],]
  dat1[[i]] &lt;- tmp1[order(tmp1$RT),]
}


colors &lt;- RColorBrewer:::brewer.pal(9, "Set1")

par(pty='s')
plot(dat0[[1]]$RT, dat0[[1]]$D, col="grey60", ylim=c(0, 1),
     type='l', xlab='Time(s)', ylab='Joint density', cex.lab=2,
     cex.axis = 1.5)
lines(dat1[[1]]$RT, dat1[[1]]$D)

for(i in 2:nw)
{
  lines(dat0[[i]]$RT, dat0[[i]]$D, lwd=1, col=colors[i])
  lines(dat1[[i]]$RT, dat1[[i]]$D, col=colors[i])
}

## ggplot 2
x0$TYPE &lt;- 'Simulation'
x1$TYPE &lt;- 'Prediction'
tmp0 &lt;- x0[, c("RT", "D", "R", "TYPE")]
tmp1 &lt;- x2[, c("RT", "D", "R", "TYPE")]
x2 &lt;- rbind(tmp0, tmp1)

p0 &lt;- ggplot(x2, aes(x=RT, y=D, colour=R)) +
  geom_line(aes(linetype = TYPE)) +
  xlab("DT(s)") + ylab("Joint density") +
  coord_cartesian(ylim=c(0, 1)) +
  # facet_wrap(~TYPE) +
  theme_bw(base_size=14) +
  theme(aspect.ratio=1,
        legend.position = 'none')

</code></pre></div></div>

<p><img src="/images/cognitive-model/nonzero_drift_density.png" alt="nonzero-drift" />
Figure 4. The nonzero probabiity densities of the 2-D diffusion process.</p>

<h1 id="helper-functions">Helper functions</h1>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## This function is adpated from Smith's (2016) dirichlet1.m 
histogram_cddm &lt;- function(d, P, nw=11, tmax=2, h=1e-4)
{
  # d
  # pvec=p.vector
  # nw=11
  # tmax=2
  # h=1e-4
  v1 &lt;- P[1];
  v2 &lt;- P[2];
  a  &lt;- P[3];
  t0 &lt;- P[4]
  s1 &lt;- P[5];
  s2 &lt;- P[6];

  DT &lt;- d[,2] - P[4]
  A  &lt;- d[,3]

  ## Angles
  w &lt;- 2*pi/nw
  Theta &lt;- seq(-pi, pi-w, w)
  Thetabound &lt;- c(Theta + w/2);

  ## Time
  time_grid &lt;- seq(0, tmax, h)
  ntime_grid &lt;- length(time_grid);
  tbound &lt;- c(time_grid[1] - h/2, time_grid + h/2);

  Mt  &lt;- Nt &lt;- Pmt &lt;- numeric(nw)
  Gt  &lt;- Gt_count &lt;- matrix(numeric(nw*ntime_grid), nrow=nw)

  n &lt;- nrow(d)

  for (i in 1:n)
  {
    tmp0 &lt;- which( A[i] &lt;= Thetabound )
    thetaindex &lt;- min( tmp0, na.rm=TRUE )

    ##  between -pi and Thetabound(1), pool into last
    if ( is.infinite(thetaindex) ) thetaindex &lt;- 1

    tindex &lt;- min( max( which( DT[i] &gt; tbound) ), ntime_grid) ##  Pool into last bin.
    Nt[thetaindex] = Nt[thetaindex] + 1;
    Mt[thetaindex] = Mt[thetaindex] + DT[i];
    Gt[thetaindex,tindex]       &lt;- Gt[thetaindex, tindex] + 1;
    Gt_count[thetaindex,tindex] &lt;- Gt_count[thetaindex, tindex] + 1;
  }

  Mt &lt;- Mt / Nt; ## Average time per theta group
  Pt &lt;- Nt / n;

  ## Gt densities
  filter &lt;- cos( seq(-pi/2, pi/2, .025))
  filter &lt;- filter / sum(filter);  #  Normalize mass in filter

  for (i in 1:nw)
  {
    Gtfi &lt;- pracma::conv(Gt[i,], filter)
    ## %Gt(i,:) = Gtfi(1:szt)./(Nt(i) * h +eps); % conditional
    Gt[i,] &lt;- Gtfi[1:ntime_grid] / (n  * h);  ## % joint density
  }

  for (i in 1:nw) {
    Pmt[i] &lt;- exp(a*cos(Theta[i])*v1 / s1^2 + a*sin(Theta[i])*v2 / s2^2)
  }

  Commonscale &lt;-  exp(-0.5 * (v1^2/s1^2 + v2^2/s2^2) * time_grid);
  # Multiply theta-dependent drift term by invariant time-dependent term
  Mtscale &lt;- as.matrix(Pmt) %*% Commonscale;
  Pt &lt;- Pt / w; # % To make into a density estimate.


  thidx &lt;- factor(round(Theta, 2))
  ## ------------------------------------------------------------------------##
  ## Note that to get the joint density of hitting
  ## angles and resposne times, the densities were divided by w
  ## ------------------------------------------------------------------------##
  x0 &lt;- NULL
  for(i in 1:nw) {
    tmp0 &lt;- data.frame(R = thidx[i], RT = time_grid+t0, D = Gt[i,]/w)
    x0 &lt;- rbind(x0, tmp0)
  }


  return(list(Theta=Theta, Mt=Mt, Pt=Pt, time_grid=time_grid, Gt=Gt, Pmt=Pmt,
              Mtscale=Mtscale, Gt_count=Gt_count, d=x0))
}
</code></pre></div></div>


			</article>
		</section>

		<script>
			document.getElementById("open-nav").addEventListener("click", function () {
				document.body.classList.toggle("nav-open");
			});

			
		</script>

		  
		</script>
	</body>
</html>
